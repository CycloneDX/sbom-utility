// SPDX-License-Identifier: Apache-2.0
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package schema

import "sort"

// named BOM slice types
type CDXAdvisorySlice []CDXAdvisory
type CDXAffectSlice []CDXAffect
type CDXRatingSlice []CDXRating
type CDXSupportingMaterialSlice []CDXSupportingMaterial
type CDXVulnerabilityReferenceSlice []CDXVulnerabilityReference
type CDXVulnerabilitySlice []CDXVulnerability

// ====================================================================
// Struct Normalizers
// ====================================================================

// type CDXVulnerability struct {
// TODO: Tools interface{} (i.e., need to test for which type it is in order to Normalize)
//
//		Analysis       *CDXAnalysis                 `json:"analysis,omitempty"`       // v1.4: anon. type
//	}
func (vulnerability *CDXVulnerability) Normalize() {
	// Sort: References
	if vulnerability.References != nil {
		CDXVulnerabilityReferenceSlice(*vulnerability.References).Normalize()
	}
	// Sort: Ratings
	if vulnerability.Ratings != nil {
		CDXRatingSlice(*vulnerability.Ratings).Normalize()
	}
	// Sort: Cwes
	if vulnerability.Cwes != nil {
		sort.Ints(*vulnerability.Cwes)
	}
	// Sort: Advisories
	if vulnerability.Advisories != nil {
		CDXAdvisorySlice(*vulnerability.Advisories).Normalize()
	}
	// Sort: Credits substructure
	if vulnerability.Credits != nil {
		vulnerability.Credits.Normalize()
	}
	// TODO: Sort: Tools
	// Sort: Analysis
	if vulnerability.Analysis != nil {
		vulnerability.Analysis.Normalize()
	}
	// Sort: Affects
	if vulnerability.Affects != nil {
		CDXAffectSlice(*vulnerability.Affects).Normalize()
	}
	// Sort: ProofOfConcept
	if vulnerability.ProofOfConcept != nil {
		vulnerability.ProofOfConcept.Normalize()
	}
	// Sort: Properties
	if vulnerability.Properties != nil {
		CDXPropertySlice(*vulnerability.Properties).Normalize()
	}
}

func (credit *CDXCredit) Normalize() {
	if credit.Organizations != nil {
		CDXOrganizationalEntitySlice(*credit.Organizations).Normalize()
	}
	if credit.Individuals != nil {
		CDXOrganizationalContactSlice(*credit.Individuals).Normalize()
	}
}

func (poc *CDXProofOfConcept) Normalize() {
	if poc.SupportingMaterial != nil {
		CDXSupportingMaterialSlice(*poc.SupportingMaterial).Normalize()
	}
}

func (analysis *CDXAnalysis) Normalize() {
	if analysis.Response != nil {
		sort.Strings(*analysis.Response)
	}
}

// ====================================================================
// Slice Normalizers
// ====================================================================
func (slice CDXVulnerabilitySlice) Normalize() {
	sort.Slice(slice, func(i, j int) bool {
		element1 := slice[i]
		element2 := slice[j]
		return comparatorVulnerability(element1, element2)
	})
	// TODO: sort (nested) children of each vulnerability
	for _, vulnerability := range slice {
		vulnerability.Normalize()
	}
}

func (slice CDXRatingSlice) Normalize() {
	sort.Slice(slice, func(i, j int) bool {
		element1 := slice[i]
		element2 := slice[j]
		return comparatorRating(element1, element2)
	})
}

func (slice CDXVulnerabilityReferenceSlice) Normalize() {
	sort.Slice(slice, func(i, j int) bool {
		element1 := slice[i]
		element2 := slice[j]
		return comparatorVulnerabilityReference(element1, element2)
	})
}

func (slice CDXAdvisorySlice) Normalize() {
	sort.Slice(slice, func(i, j int) bool {
		element1 := slice[i]
		element2 := slice[j]
		return comparatorAdvisory(element1, element2)
	})
}

func (slice CDXAffectSlice) Normalize() {
	sort.Slice(slice, func(i, j int) bool {
		element1 := slice[i]
		element2 := slice[j]
		return comparatorAffect(element1, element2)
	})
}

func (slice CDXSupportingMaterialSlice) Normalize() {
	sort.Slice(slice, func(i, j int) bool {
		element1 := slice[i]
		element2 := slice[j]
		return comparatorSupportingMaterial(element1, element2)
	})
}

// ====================================================================
// Struct comparators
// ====================================================================

// NOTE: there are NO required fields in the vulnerability object's data schema
// sort by we will sort using fields that may contain local, identifying values
// TODO sort "advisories", "cwes" and "ratings.source" and "affects.ref"
func comparatorVulnerability(element1 CDXVulnerability, element2 CDXVulnerability) bool {
	// optional identifiers: "id"
	if element1.Id != element2.Id {
		return element1.Id < element2.Id
	}
	// pseudo-required fields:
	if element1.Created != element2.Created {
		return element1.Created < element2.Created
	}
	if element1.Published != element2.Published {
		return element1.Published < element2.Published
	}
	if element1.Updated != element2.Updated {
		return element1.Updated < element2.Updated
	}
	// other optional "tie breakers":
	if element1.Source != nil && element2.Source != nil {
		return comparatorSource(*element1.Source, *element2.Source)
	}
	// sort by (sometimes an identifier): "bom-ref"
	if element1.BOMRef != nil && element2.BOMRef != nil {
		return comparatorRefType(*element1.BOMRef, *element2.BOMRef)
	}
	// default: preserve existing order
	return true
}

func comparatorAdvisory(element1 CDXAdvisory, element2 CDXAdvisory) bool {
	if element1.Title != element2.Title {
		return element1.Title < element2.Title
	}
	if element1.Url != element2.Url {
		return element1.Url < element2.Url
	}
	return true
}

// TODO: Look into sort by: Versions *[]CDXVersionRange (after normalized)
func comparatorAffect(element1 CDXAffect, element2 CDXAffect) bool {
	if element1.Ref != nil && element2.Ref != nil {
		return comparatorRefLinkType(*element1.Ref, *element2.Ref)
	}
	return true
}

func comparatorRating(element1 CDXRating, element2 CDXRating) bool {
	if element1.Severity != element2.Severity {
		return element1.Severity < element2.Severity
	}
	if element1.Score != element2.Score {
		return element1.Score < element2.Score
	}
	if element1.Method != element2.Method {
		return element1.Method < element2.Method
	}
	if element1.Source != nil && element2.Source != nil {
		return comparatorSource(*element1.Source, *element2.Source)
	}
	// default: preserve existing order
	return true
}

func comparatorSource(element1 CDXVulnerabilitySource, element2 CDXVulnerabilitySource) bool {
	if element1.Name != element2.Name {
		return element1.Name < element2.Name
	}
	if element1.Url != element2.Url {
		return element1.Url < element2.Url
	}
	return true
}

func comparatorSupportingMaterial(element1 CDXSupportingMaterial, element2 CDXSupportingMaterial) bool {
	if element1.ContentType != element2.ContentType {
		return element1.ContentType < element2.ContentType
	}
	if element1.Encoding != element2.Encoding {
		return element1.Encoding < element2.Encoding
	}
	if element1.Content != element2.Content {
		return element1.Content < element2.Content
	}
	return true
}

func comparatorVulnerabilityReference(element1 CDXVulnerabilityReference, element2 CDXVulnerabilityReference) bool {
	if element1.Id != element2.Id {
		return element1.Id < element2.Id
	}
	// other optional "tie breakers":
	if element1.Source != nil && element2.Source != nil {
		return comparatorSource(*element1.Source, *element2.Source)
	}
	return true
}
