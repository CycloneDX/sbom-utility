/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cmd

import (
	"encoding/csv"
	"fmt"
	"io"
	"reflect"
	"sort"
	"strings"
	"text/tabwriter"

	"github.com/CycloneDX/sbom-utility/common"
	"github.com/CycloneDX/sbom-utility/log"
	"github.com/CycloneDX/sbom-utility/schema"
	"github.com/CycloneDX/sbom-utility/utils"
	"github.com/jwangsadinata/go-multimap"
	"github.com/spf13/cobra"
)

const (
	SUBCOMMAND_VULNERABILITY_LIST = "list"
)

const (
	FLAG_VULN_SUMMARY = "summary"
)

var VALID_SUBCOMMANDS_VULNERABILITY = []string{SUBCOMMAND_VULNERABILITY_LIST}

// data (filter) keys
const (
	VULN_DATA_KEY_ID                     = "id"                     // summary
	VULN_DATA_KEY_BOM_REF                = "bom-ref"                // full (optional, internal reference)
	VULN_DATA_KEY_CWES                   = "cwe-ids"                // full (Common Weakness Enumeration (CWE))
	VULN_DATA_KEY_CVSS_SEVERITY          = "cvss-severity"          // summary (CVSS Severity, V3.1 ot v2.0)
	VULN_DATA_KEY_SOURCE_NAME            = "source-name"            // summary
	VULN_DATA_KEY_SOURCE_URL             = "source-url"             // full
	VULN_DATA_KEY_PUBLISHED              = "published"              // summary
	VULN_DATA_KEY_UPDATED                = "updated"                // full
	VULN_DATA_KEY_CREATED                = "created"                // full
	VULN_DATA_KEY_REJECTED               = "rejected"               // full
	VULN_DATA_KEY_ANALYSIS_STATE         = "analysis-state"         // full
	VULN_DATA_KEY_ANALYSIS_JUSTIFICATION = "analysis-justification" // full
	VULN_DATA_KEY_DESC                   = "description"            // summary
)

// NOTE: columns will be output in order they are listed here:
// NOTE: data marked as "summary" data is informed by the output from the NVD database service itself
// this includes fields that have ISO 8601 date-time fields are truncated to show date only
var VULNERABILITY_LIST_ROW_DATA = []ColumnFormatData{
	{VULN_DATA_KEY_ID, DEFAULT_COLUMN_TRUNCATE_LENGTH, REPORT_SUMMARY_DATA_TRUE, false},
	{VULN_DATA_KEY_BOM_REF, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_CWES, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_CVSS_SEVERITY, DEFAULT_COLUMN_TRUNCATE_LENGTH, REPORT_SUMMARY_DATA_TRUE, false},
	{VULN_DATA_KEY_SOURCE_NAME, DEFAULT_COLUMN_TRUNCATE_LENGTH, REPORT_SUMMARY_DATA_TRUE, false},
	{VULN_DATA_KEY_SOURCE_URL, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_PUBLISHED, DEFAULT_COLUMN_TRUNCATE_LENGTH, REPORT_SUMMARY_DATA_TRUE, false},
	{VULN_DATA_KEY_UPDATED, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_CREATED, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_REJECTED, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_ANALYSIS_STATE, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_ANALYSIS_JUSTIFICATION, DEFAULT_COLUMN_TRUNCATE_LENGTH, false, false},
	{VULN_DATA_KEY_DESC, VULN_TRUNCATE_DESC_LEN, REPORT_SUMMARY_DATA_TRUE, REPORT_REPLACE_LINE_FEEDS_TRUE},
}

// TODO make configurable via flag
const VULN_TRUNCATE_DESC_LEN = 32

// Command help formatting
const (
	FLAG_VULNERABILITY_OUTPUT_FORMAT_HELP = "format vulnerability output"
	FLAG_VULN_SUMMARY_HELP                = "summarize vulnerability information when listing in supported formats"
)

var VULNERABILITY_LIST_SUPPORTED_FORMATS = MSG_SUPPORTED_OUTPUT_FORMATS_HELP +
	strings.Join([]string{FORMAT_TEXT, FORMAT_CSV, FORMAT_MARKDOWN, FORMAT_JSON}, ", ")

// Vuln. command informational messages
const (
	MSG_OUTPUT_NO_VULNERABILITIES_FOUND = "[WARN] no matching vulnerabilities found for query"
)

func NewCommandVulnerability() *cobra.Command {
	var command = new(cobra.Command)
	command.Use = CMD_USAGE_VULNERABILITY_LIST
	command.Short = "Report on vulnerabilities found in the BOM input file"
	command.Long = "Report on vulnerabilities found in the BOM input file"
	command.Flags().StringVarP(&utils.GlobalFlags.PersistentFlags.OutputFormat, FLAG_FILE_OUTPUT_FORMAT, "", FORMAT_TEXT,
		FLAG_VULNERABILITY_OUTPUT_FORMAT_HELP+VULNERABILITY_LIST_SUPPORTED_FORMATS)
	command.Flags().StringP(FLAG_REPORT_WHERE, "", "", FLAG_REPORT_WHERE_HELP)
	command.Flags().BoolVarP(
		&utils.GlobalFlags.VulnerabilityFlags.Summary,
		FLAG_VULN_SUMMARY, "", false,
		FLAG_VULN_SUMMARY_HELP)
	command.RunE = vulnerabilityCmdImpl
	command.ValidArgs = VALID_SUBCOMMANDS_VULNERABILITY
	command.PreRunE = func(cmd *cobra.Command, args []string) (err error) {

		// TODO: pre-validate if --where keys are valid for this command

		// the vuln. command requires at least 1 valid subcommand (argument)
		getLogger().Tracef("args: %v\n", args)
		if len(args) == 0 {
			return getLogger().Errorf("Missing required argument(s).")
		} else if len(args) > 1 {
			return getLogger().Errorf("Too many arguments provided: %v", args)
		}

		// Make sure subcommand is known
		if !preRunTestForSubcommand(command, VALID_SUBCOMMANDS_VULNERABILITY, args[0]) {
			return getLogger().Errorf("Subcommand provided is not valid: `%v`", args[0])
		}

		// Test for required flags (parameters)
		err = preRunTestForInputFile(cmd, args)

		return
	}
	return command
}

// Cobra command callback
func vulnerabilityCmdImpl(cmd *cobra.Command, args []string) (err error) {
	getLogger().Enter(args)
	defer getLogger().Exit()

	// Create output writer
	outputFilename := utils.GlobalFlags.PersistentFlags.OutputFile
	outputFile, writer, err := createOutputFile(outputFilename)
	getLogger().Tracef("outputFile: `%v`; writer: `%v`", outputFile, writer)

	// use function closure to assure consistent error output based upon error type
	defer func() {
		// always close the output file
		if outputFile != nil {
			err = outputFile.Close()
			getLogger().Infof("Closed output file: `%s`", outputFilename)
		}
	}()

	// process filters supplied on the --where command flag
	whereFilters, err := processWhereFlag(cmd)

	if err != nil {
		return
	}

	err = ListVulnerabilities(writer, utils.GlobalFlags.PersistentFlags, utils.GlobalFlags.VulnerabilityFlags, whereFilters)

	return
}

// Assure all errors are logged
func processVulnerabilityListResults(err error) {
	if err != nil {
		// No special processing at this time
		getLogger().Error(err)
	}
}

func sortVulnerabilities(entries []multimap.Entry) {
	// Sort by Id, Created date (descending)
	sort.Slice(entries, func(i, j int) bool {
		vuln1 := (entries[i].Value).(schema.VulnerabilityInfo)
		vuln2 := (entries[j].Value).(schema.VulnerabilityInfo)
		if vuln1.Id != vuln2.Id {
			return vuln1.Id > vuln2.Id
		}

		return vuln1.Created > vuln2.Created
	})
}

// NOTE: vulnerability type data has already been validated
func ListVulnerabilities(writer io.Writer, persistentFlags utils.PersistentCommandFlags, flags utils.VulnerabilityCommandFlags, whereFilters []common.WhereFilter) (err error) {
	getLogger().Enter()
	defer getLogger().Exit()

	// use function closure to assure consistent error output based upon error type
	defer func() {
		if err != nil {
			processVulnerabilityListResults(err)
		}
	}()

	// Note: returns error if either file load or unmarshal to JSON map fails
	var document *schema.BOM
	document, err = LoadInputBOMFileAndDetectSchema()

	if err != nil {
		return
	}

	// Hash all vulnerabilities within input file
	getLogger().Infof("Scanning document for vulnerabilities...")
	err = loadDocumentVulnerabilities(document, whereFilters)

	if err != nil {
		return
	}

	format := persistentFlags.OutputFormat
	getLogger().Infof("Outputting listing (`%s` format)...", format)
	switch format {
	case FORMAT_TEXT:
		DisplayVulnListText(document, writer, flags)
	case FORMAT_CSV:
		err = DisplayVulnListCSV(document, writer, flags)
	case FORMAT_MARKDOWN:
		err = DisplayVulnListMarkdown(document, writer, flags)
	case FORMAT_JSON:
		DisplayVulnListJson(document, writer, flags)
	default:
		// Default to Text output for anything else (set as flag default)
		getLogger().Warningf("Listing not supported for `%s` format; defaulting to `%s` format...",
			format, FORMAT_JSON)
		DisplayVulnListText(document, writer, flags)
	}

	return
}

func loadDocumentVulnerabilities(document *schema.BOM, whereFilters []common.WhereFilter) (err error) {
	getLogger().Enter()
	defer getLogger().Exit(err)

	// At this time, fail SPDX format SBOMs as "unsupported" (for "any" format)
	if !document.FormatInfo.IsCycloneDx() {
		err = schema.NewUnsupportedFormatForCommandError(
			document.FormatInfo.CanonicalName,
			document.GetFilename(),
			CMD_LICENSE, FORMAT_ANY)
		return
	}

	// Before looking for license data, fully unmarshal the SBOM
	// into named structures
	if err = document.UnmarshalCycloneDXBOM(); err != nil {
		return
	}

	// Hash all components found in the (root).components[] (+ "nested" components)
	pVulnerabilities := document.GetCdxVulnerabilities()
	if pVulnerabilities != nil && len(*pVulnerabilities) > 0 {
		if err = hashVulnerabilities(document, *pVulnerabilities, whereFilters); err != nil {
			return
		}
	}

	return
}

// We need to hash our own informational structure around the CDX data in order
// to simplify --where queries to command line users
func hashVulnerabilities(bom *schema.BOM, vulnerabilities []schema.CDXVulnerability, whereFilters []common.WhereFilter) (err error) {
	getLogger().Enter()
	defer getLogger().Exit(err)

	for _, cdxVulnerability := range vulnerabilities {
		_, err = hashVulnerability(bom, cdxVulnerability, whereFilters)
		if err != nil {
			return
		}
	}
	return
}

// Hash a CDX Component and recursively those of any "nested" components
// TODO we should WARN if version is not a valid semver (e.g., examples/cyclonedx/BOM/laravel-7.12.0/bom.1.3.json)
func hashVulnerability(bom *schema.BOM, cdxVulnerability schema.CDXVulnerability, whereFilters []common.WhereFilter) (vi *schema.VulnerabilityInfo, err error) {
	getLogger().Enter()
	defer getLogger().Exit(err)
	var vulnInfo schema.VulnerabilityInfo
	vi = &vulnInfo

	if reflect.DeepEqual(cdxVulnerability, schema.CDXVulnerability{}) {
		err = getLogger().Errorf("invalid vulnerability info: missing or empty : %v ", cdxVulnerability)
		return
	}

	if cdxVulnerability.Id == "" {
		getLogger().Warningf("vulnerability missing required value `id` : %v ", cdxVulnerability)
	}

	if cdxVulnerability.Published == "" {
		getLogger().Warningf("vulnerability (`%s`) missing `published` date", cdxVulnerability.Id)
	}

	if cdxVulnerability.Created == "" {
		getLogger().Warningf("vulnerability (`%s`) missing `created` date", cdxVulnerability.Id)
	}

	if len(cdxVulnerability.Ratings) == 0 {
		getLogger().Warningf("vulnerability (`%s`) missing `ratings`", cdxVulnerability.Id)
	}

	// hash any component w/o a license using special key name
	vulnInfo.Vulnerability = cdxVulnerability
	vulnInfo.BOMRef = cdxVulnerability.BOMRef.String()
	vulnInfo.Id = cdxVulnerability.Id

	// Truncate dates from 2023-02-02T00:00:00.000Z to 2023-02-02
	// Note: if validation errors are found by the "truncate" function,
	// it will emit an error and return the original (failing) value
	dateTime, _ := utils.TruncateTimeStampISO8601Date(cdxVulnerability.Created)
	vulnInfo.Created = dateTime

	dateTime, _ = utils.TruncateTimeStampISO8601Date(cdxVulnerability.Published)
	vulnInfo.Published = dateTime

	dateTime, _ = utils.TruncateTimeStampISO8601Date(cdxVulnerability.Updated)
	vulnInfo.Updated = dateTime

	dateTime, _ = utils.TruncateTimeStampISO8601Date(cdxVulnerability.Rejected)
	vulnInfo.Rejected = dateTime

	vulnInfo.Description = cdxVulnerability.Description

	// Source object: retrieve report fields from nested objects
	vulnInfo.Source = cdxVulnerability.Source
	vulnInfo.SourceName = cdxVulnerability.Source.Name
	vulnInfo.SourceUrl = cdxVulnerability.Source.Url

	// TODO: replace empty Analysis values with "UNDEFINED"
	vulnInfo.AnalysisState = cdxVulnerability.Analysis.State
	if vulnInfo.AnalysisState == "" {
		vulnInfo.AnalysisState = schema.VULN_ANALYSIS_STATE_EMPTY
	}

	vulnInfo.AnalysisJustification = cdxVulnerability.Analysis.Justification
	if vulnInfo.AnalysisJustification == "" {
		vulnInfo.AnalysisJustification = schema.VULN_ANALYSIS_STATE_EMPTY
	}
	vulnInfo.AnalysisResponse = cdxVulnerability.Analysis.Response
	if len(vulnInfo.AnalysisResponse) == 0 {
		vulnInfo.AnalysisResponse = []string{schema.VULN_ANALYSIS_STATE_EMPTY}
	}

	// Convert []int to []string for --where filter
	// TODO see if we can eliminate this conversion and handle while preparing report data
	// as this SHOULD appear there as []interface{}
	if len(cdxVulnerability.Cwes) > 0 {
		vulnInfo.CweIds = strings.Fields(strings.Trim(fmt.Sprint(cdxVulnerability.Cwes), "[]"))
	}

	// CVSS Score 	Qualitative Rating
	// 0.0 	        None
	// 0.1 – 3.9 	Low
	// 4.0 – 6.9 	Medium
	// 7.0 – 8.9 	High
	// 9.0 – 10.0 	Critical

	// TODO: if summary report, see if more than one severity can be shown without clogging up column data
	numRatings := len(cdxVulnerability.Ratings)
	if numRatings > 0 {
		//var sourceMatch int
		for _, rating := range cdxVulnerability.Ratings {
			// defer to same source as the top-level vuln. declares
			fSeverity := fmt.Sprintf("%s: %v (%s)", rating.Method, rating.Score, rating.Severity)
			// give listing priority to ratings that matches top-level vuln. reporting source
			if rating.Source.Name == cdxVulnerability.Source.Name {
				// prepend to slice
				vulnInfo.CvssSeverity = append([]string{fSeverity}, vulnInfo.CvssSeverity...)
				continue
			}
			vulnInfo.CvssSeverity = append(vulnInfo.CvssSeverity, fSeverity)
		}

	} else {
		// Set first entry to empty value (i.e., "none")
		vulnInfo.CvssSeverity = append(vulnInfo.CvssSeverity, schema.VULN_RATING_EMPTY)
	}

	var match bool = true
	if len(whereFilters) > 0 {
		mapVulnInfo, _ := utils.ConvertStructToMap(vulnInfo)
		match, _ = whereFilterMatch(mapVulnInfo, whereFilters)
	}

	if match {
		bom.VulnerabilityMap.Put(vulnInfo.Id, vulnInfo)

		getLogger().Tracef("Put: %s (`%s`), `%s`)",
			vulnInfo.Id, vulnInfo.Description, vulnInfo.BOMRef)
	}

	return
}

// NOTE: This list is NOT de-duplicated
// TODO: Add a --no-title flag to skip title output
func DisplayVulnListText(bom *schema.BOM, output io.Writer, flags utils.VulnerabilityCommandFlags) {
	getLogger().Enter()
	defer getLogger().Exit()

	// initialize tabwriter
	w := new(tabwriter.Writer)
	defer w.Flush()

	// min-width, tab-width, padding, pad-char, flags
	w.Init(output, 8, 2, 2, ' ', 0)

	// create title row and underline row from slices of optional and compulsory titles
	titles, underlines := prepareReportTitleData(VULNERABILITY_LIST_ROW_DATA, flags.Summary)

	// Add tabs between column titles for the tabWRiter
	fmt.Fprintf(w, "%s\n", strings.Join(titles, "\t"))
	fmt.Fprintf(w, "%s\n", strings.Join(underlines, "\t"))

	// Display a warning "missing" in the actual output and return (short-circuit)
	entries := bom.VulnerabilityMap.Entries()

	// Emit no license warning into output
	if len(entries) == 0 {
		fmt.Fprintf(w, "%s\n", MSG_OUTPUT_NO_VULNERABILITIES_FOUND)
		return
	}

	// Sort vulnerabilities prior to outputting
	sortVulnerabilities(entries)

	// Emit row data
	var line []string
	for _, entry := range entries {
		// TODO surface error data to top-level command
		line, _ = prepareReportLineData(
			entry.Value.(schema.VulnerabilityInfo),
			VULNERABILITY_LIST_ROW_DATA,
			flags.Summary,
		)
		fmt.Fprintf(w, "%s\n", strings.Join(line, "\t"))
	}
}

// TODO: Add a --no-title flag to skip title output
func DisplayVulnListCSV(bom *schema.BOM, output io.Writer, flags utils.VulnerabilityCommandFlags) (err error) {
	getLogger().Enter()
	defer getLogger().Exit()

	// initialize writer and prepare the list of entries (i.e., the "rows")
	w := csv.NewWriter(output)
	defer w.Flush()

	// Create title row data as []string
	titles, _ := prepareReportTitleData(VULNERABILITY_LIST_ROW_DATA, flags.Summary)

	if err = w.Write(titles); err != nil {
		return getLogger().Errorf("error writing to output (%v): %s", titles, err)
	}

	// Display a warning "missing" in the actual output and return (short-circuit)
	entries := bom.VulnerabilityMap.Entries()

	// Emit no vuln. found warning into output
	if len(entries) == 0 {
		currentRow := []string{MSG_OUTPUT_NO_VULNERABILITIES_FOUND}
		if err = w.Write(currentRow); err != nil {
			// unable to emit an error message into output stream
			return getLogger().Errorf("error writing to output (%v): %s", currentRow, err)
		}
		return fmt.Errorf(currentRow[0])
	}

	// Sort vulnerabilities prior to outputting
	sortVulnerabilities(entries)

	// Emit row data
	var line []string
	for _, entry := range entries {
		// TODO surface error data to top-level command
		line, _ = prepareReportLineData(
			entry.Value.(schema.VulnerabilityInfo),
			VULNERABILITY_LIST_ROW_DATA,
			flags.Summary,
		)

		if err = w.Write(line); err != nil {
			err = getLogger().Errorf("csv.Write: %w", err)
		}
	}

	return
}

// TODO: Add a --no-title flag to skip title output
func DisplayVulnListMarkdown(bom *schema.BOM, output io.Writer, flags utils.VulnerabilityCommandFlags) (err error) {
	getLogger().Enter()
	defer getLogger().Exit()

	// Create title row data as []string
	titles, _ := prepareReportTitleData(VULNERABILITY_LIST_ROW_DATA, flags.Summary)

	// create title row
	titleRow := createMarkdownRow(titles)
	fmt.Fprintf(output, "%s\n", titleRow)

	alignments := createMarkdownColumnAlignment(titles)
	alignmentRow := createMarkdownRow(alignments)
	fmt.Fprintf(output, "%s\n", alignmentRow)

	// Display a warning "missing" in the actual output and return (short-circuit)
	entries := bom.VulnerabilityMap.Entries()

	// Emit no vuln. found warning into output
	if len(entries) == 0 {
		fmt.Fprintf(output, "%s\n", MSG_OUTPUT_NO_VULNERABILITIES_FOUND)
		return fmt.Errorf(MSG_OUTPUT_NO_VULNERABILITIES_FOUND)
	}

	// Sort vulnerabilities prior to outputting
	sortVulnerabilities(entries)

	// Emit row data
	var line []string
	var lineRow string
	for _, entry := range entries {
		// TODO surface error data to top-level command
		line, _ = prepareReportLineData(
			entry.Value.(schema.VulnerabilityInfo),
			VULNERABILITY_LIST_ROW_DATA,
			flags.Summary,
		)
		lineRow = createMarkdownRow(line)
		fmt.Fprintf(output, "%s\n", lineRow)

	}

	return
}

// Output filtered list of vulnerabilities as JSON
func DisplayVulnListJson(bom *schema.BOM, output io.Writer, flags utils.VulnerabilityCommandFlags) {
	getLogger().Enter()
	defer getLogger().Exit()

	var vulnInfo schema.VulnerabilityInfo
	var vulnList []schema.CDXVulnerability

	for _, key := range bom.VulnerabilityMap.KeySet() {
		arrVulnInfo, _ := bom.VulnerabilityMap.Get(key)

		for _, iInfo := range arrVulnInfo {
			vulnInfo = iInfo.(schema.VulnerabilityInfo)
			vulnList = append(vulnList, vulnInfo.Vulnerability)
		}
	}
	json, _ := log.FormatInterfaceAsJson(vulnList)

	// Note: JSON data files MUST ends in a newline s as this is a POSIX standard
	fmt.Fprintf(output, "%s\n", json)
}
